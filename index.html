<!DOCTYPE html>
<html lang="es">

<head>

    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Clasificaci√≥n General CK</title>

    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&family=Russo+One&display=swap"
        rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <link rel="manifest" href="./manifest.json">

    <link rel="stylesheet" href="./styles.css">
</head>

<body>
    <!-- Pull to Refresh Indicator -->
    <div id="refresh-indicator">
        <i class="fa-solid fa-arrow-down pull-icon"></i>
    </div>
    <nav class="navbar">
        <a href="./" class="nav-link">üèÜ <br> Clasificaci√≥n</a>
        <a href="./inscripcion/" class="nav-link">üìù <br> Preinscripci√≥n</a>
        <a href="./sorteo/" class="nav-link">üèéÔ∏è <br> Sorteo</a>
    </nav>
    <div class="container">
        <h2 style="text-align: center;"><i class="fa-solid fa-trophy"></i> Clasificaci√≥n</h2>

        <div id="podium-container" class="podium"></div>

        <div id="list-container" class="list"></div>

    </div>


    <script>
        // ==========================================
        // ‚öôÔ∏è CONFIGURACI√ìN
        // ==========================================

        const GOOGLE_CSV_LINK = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTlPsGq-SypD4WPitvnR7JcluA8_6-5ePtuzyf5zFGJ31eppN55iUIHsKo0oduOZ9AVyVTf6VkPvTyu/pub?output=csv";

        // Se han usado comillas invertidas (\`) para evitar cualquier problema de caracteres.
        const SHEET_URL = `https://corsproxy.io/?url=${encodeURIComponent(GOOGLE_CSV_LINK)}`;
        // ==========================================
        // üöÄ L√ìGICA DE CARGA DE DATOS
        // ==========================================


        async function fetchWithRetry(url, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    console.log(`Intentando cargar datos (Intento ${i + 1}/${maxRetries})...`);
                    const response = await fetch(url);

                    // Si la respuesta es OK (c√≥digo 200), la devolvemos inmediatamente
                    if (response.ok) {
                        console.log('Carga de datos exitosa.');
                        return response;
                    }
                } catch (error) {
                    console.warn(`Fallo en el intento ${i + 1}. Error: ${error.message}`);
                    // Si no es el √∫ltimo intento, esperamos y reintentamos
                    if (i < maxRetries - 1) {
                        const waitTime = 1000 * (i + 1); // Espera 1s, luego 2s...
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    }
                }
            }
            // Si el bucle termina, significa que todos los intentos fallaron
            throw new Error("Fallo al obtener los datos despu√©s de todos los reintentos.");
        }

        async function fetchLeaderboardData() {
            const podiumContainer = document.getElementById('podium-container');
            const listContainer = document.getElementById('list-container');

            listContainer.innerHTML = '';
            listContainer.innerHTML = '<div style="text-align:center; color:#94a3b8;"><i class="fa-solid fa-spinner fa-spin"></i> Cargando datos del campeonato...</div>';

            try {
                // Usamos la nueva funci√≥n con reintentos
                const response = await fetchWithRetry(SHEET_URL);

                // El resto sigue igual que tu versi√≥n anterior (manejo de CSV)
                const data = await response.text();

                const drivers = parseCSV(data);

                renderLeaderboard(drivers);

            } catch (error) {
                console.error("Error al cargar el Google Sheet:", error);
                listContainer.innerHTML = `<div style="text-align:center; color:#ef4444;">Error al obtener los datos de la clasificaci√≥n, recarga la web.</div>`;
            }
        }

        // Funci√≥n auxiliar para leer el CSV crudo
        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const drivers = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const parts = line.split(',');

                if (parts.length >= 3) {
                    drivers.push({
                        name: parts[0].trim(),
                        team: parts[1].trim(),
                        points: parseInt(parts[2].trim()) || 0,
                        photo: parts[3] ? parts[3].trim() : "https://www.w3schools.com/howto/img_avatar.png",
                        podiums: parseInt(parts[4].trim()) || 0,
                        poles: parseInt(parts[5].trim()) || 0,
                        wins: parseInt(parts[6].trim()) || 0,
                        division: parseInt(parts[7].trim()) || 0,
                    });
                }
            }
            return drivers;
        }

        // ==========================================
        // üé® RENDERIZADO (CON ENLACES AL PERFIL)
        // ==========================================

        function renderLeaderboard(driversData) {
            const podiumContainer = document.getElementById('podium-container');
            const listContainer = document.getElementById('list-container');

            // Limpiar contenedores
            podiumContainer.innerHTML = '';
            listContainer.innerHTML = '';

            // 1. Ordenar pilotos por puntos (Mayor a menor)
            const sortedDrivers = driversData.sort((a, b) => b.points - a.points);

            // 2. Separar Top 3 del resto
            const top3 = sortedDrivers.slice(0, 3);
            const rest = sortedDrivers.slice(3);

            // 3. Renderizar Podio (Top 3)
            let podiumHTML = '';

            top3.forEach((driver, index) => {
                const rank = index + 1;
                let crownIcon = '';
                if (rank === 1) crownIcon = '<i class="fa-solid fa-medal crown"></i>';
                if (rank === 2) crownIcon = '<i class="fa-solid fa-medal crown"></i>';
                if (rank === 3) crownIcon = '<i class="fa-solid fa-medal crown"></i>';

                const driverNameUrl = encodeURIComponent(driver.name);
                // Usando Template Literals para la inyecci√≥n de HTML con ${}
                podiumHTML += `
                    <a href="./profile/index.html?driver=${driverNameUrl}" class="podium-card-link">
                    <div class="list-item rank-${rank}">
                        ${crownIcon}
                        <img src="${driver.photo}" alt="${driver.name}" class="mini-avatar">
                        <div class="info">
                        <div class="l-name">${driver.name}</div>
                        <div class="l-team">${driver.team}</div>
                        </div>
                        <div class="l-points">${driver.points} <span>PTS</span></div>
                    </div>
                    </a>
                `;
            });
            podiumContainer.innerHTML = podiumHTML;

            // 4. Renderizar Lista (Resto)
            let listHTML = '';

            rest.forEach((driver, index) => {
                const rank = index + 4;

                const driverNameUrl = encodeURIComponent(driver.name);
                listHTML += `
                    <a href="./profile/index.html?driver=${driverNameUrl}" class="list-item-link">
                    <div class="list-item">
                    <div class="rank-num">${rank}</div>
                    <img src="${driver.photo}" alt="${driver.name}" class="mini-avatar">
                    <div class="info">
                        <div class="l-name">${driver.name}</div>
                        <div class="l-team">${driver.team}</div>
                    </div>
                    <div class="l-points">${driver.points} <span>PTS</span></div>
                    </div>
                    </a>
                `;
            });
            listContainer.innerHTML = listHTML;
        }

        function askforPwaInstall() {
            const isStandalone =
                window.matchMedia("(display-mode: standalone)").matches ||
                window.navigator.standalone;

            const shown = localStorage.getItem("installHintShown");

            if (!isStandalone && !shown) {
                alert("Para instalar la app:\n1. Pulsa Compartir.\n2. 'A√±adir a pantalla de inicio'.");
                localStorage.setItem("installHintShown", "1");
            }
        }
        // Iniciar carga al abrir la web
        document.addEventListener('DOMContentLoaded', fetchLeaderboardData);
        document.addEventListener('DOMContentLoaded', askforPwaInstall);

        // ==========================================
        // üåê REGISTRO DEL SERVICE WORKER (PWA)
        // ==========================================
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW registrado con √©xito:', registration);
                    })
                    .catch(error => {
                        console.log('Fallo en el registro del SW:', error);
                    });
            });
        }
        // ==========================================
        // ==========================================
        // üîÑ PULL TO REFRESH LOGIC
        // ==========================================
        let touchStartY = 0;
        let currentY = 0;
        let isPulling = false;
        const threshold = 150; // Distancia para activar el refresh
        const indicator = document.getElementById('refresh-indicator');
        const pullIcon = indicator.querySelector('.pull-icon');

        window.addEventListener('touchstart', (e) => {
            if (window.scrollY === 0) {
                touchStartY = e.touches[0].clientY;
                isPulling = true;
            }
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            if (!isPulling) return;

            const touchY = e.touches[0].clientY;
            const diff = touchY - touchStartY;

            if (diff > 0 && window.scrollY === 0) {
                // Evitar el comportamiento por defecto solo si estamos arrastrando
                if (diff < threshold + 50) { // L√≠mite visual
                    indicator.style.top = `${diff / 2 - 60}px`; // Resistencia
                    pullIcon.style.transform = `rotate(${diff}deg)`;
                }

                if (diff > threshold) {
                    pullIcon.classList.replace('fa-arrow-down', 'fa-rotate-right');
                } else {
                    pullIcon.classList.replace('fa-rotate-right', 'fa-arrow-down');
                }
            } else {
                isPulling = false;
                indicator.style.top = '-60px';
            }
        }, { passive: true });

        window.addEventListener('touchend', async () => {
            if (!isPulling) return;
            isPulling = false;

            const topValue = parseInt(indicator.style.top || '-60');

            if (topValue > 10) { // Si se ha bajado suficiente
                indicator.style.top = '20px';
                pullIcon.style.display = 'none';

                // Recargar datos
                await fetchLeaderboardData();

                // Ocultar despu√©s de un momento
                setTimeout(() => {
                    indicator.style.top = '-60px';
                    setTimeout(() => {
                        pullIcon.style.display = 'block';
                        pullIcon.classList.replace('fa-rotate-right', 'fa-arrow-down');
                    }, 300);
                }, 1000);
            } else {
                indicator.style.top = '-60px';
            }
        });
    </script>

</body>

</html>